#' Find the peaks in a channel
#' @description This function identifies the peaks in the
#'    any given channel using the findpeaks function from the pracma package
#' @param data List of data frames generated by the read.data function and modified by apply.size
#' @param channel character vector indicating the column containing the channel of interest
#' @param minpeakheight Height thershold for peak to be called as such. Passed to findpeaks.
#' @param nups minimum number of increasing steps before a peak is reached. Passed to findpeaks.
#' @return List of dplyr data tables containing the location and size of the
#'    peaks for a given channel.
#' @seealso \code{\link{read.data,apply.size,pracma::findpeaks}}
#' @export
discover.peaks<-function(data,channel=c("ch1","ch2","ch3","ch4"),minpeakheight=200,nups=10){
  peaks<-
    map(data, function(x) select(x,channel) %>%
          unlist() %>%
          findpeaks(minpeakheight=minpeakheight,nups=nups)) %>%
    map_if(is.null,function(x) return(matrix(data=c(0,5,1,10),ncol=4))) %>%
    map(as_tibble) %>%
    map(function(x) rename(x,height=V1,position=V2,start=V3,end=V4))

  map(data,function(x) select(x,position,size.bps)) %>%
    map2(peaks,.,function(x,y) left_join(x,y,by = "position"))
}

#' Pull out a subset of the data that matches one of the discovered peaks
#' @description This function filters data to include the
#' @param data List of data frames generated by the read.data function and modified by apply.size
#' @param channel character vector indicating the column containing the channel of interest
#' @param minpeakheight Height thershold for peak to be called as such. Passed to findpeaks.
#' @param nups minimum number of increasing steps before a peak is reached. Passed to findpeaks.
#' @return List of dplyr data tables containing the location and size of the
#'    peaks for a given channel.
#' @seealso \code{\link{read.data,apply.size,pracma::findpeaks}}
#' @export
get.subset<-function(peaks,data){
  do(peaks,subset = filter(data, position >= .$start & position <= .$end))
}
get.area<-function(subset,channel=c("ch1","ch2","ch3","ch4","ch5")){
  area<-map(subset$subset,function(k) AUC(x=unlist(select(k,size.bps)),
                                          y=unlist(select(k,!!rlang::ensym(channel))),
                                          method = "spline"))
}


get.peak.area<-function(peaks,data,channel) {
  peaks<-map(peaks, function(x) mutate(x,peak = rownames(x))) %>%
    map(function(x) group_by(x,peak))
  subsets<-map2(peaks,data,get.subset)
  map_if(subsets,is.null,function(x) return(matrix(data=0,ncol=4)))
  areas<-map(subsets,get.area,channel=channel)
  suppressWarnings((map2(subsets,areas,function(x,y) group_by(x) %>%
                           mutate(area=unlist(y)))))
}

join.peaks<-function(peaks,areas){
  areas<-map(areas,function(x) select(x, -subset))
  peaks<-map(peaks, function(x) mutate(x,peak = rownames(x)))
  map2(peaks,areas,function(x,y) left_join(x,y,by="peak"))
}
